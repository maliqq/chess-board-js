#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { Board } from "../src/lib/chess";
import { parsePGN } from "../src/lib/pgn";
import type { ParsedMove } from "../src/lib/types";

type OpeningRow = {
  eco: string;
  name: string;
  pgn: string;
};

type OpeningOutput = OpeningRow & {
  moves: ParsedMove[];
  white: number;
  draws: number;
  black: number;
};

type LichessMove = {
  san: string;
  white: number;
  draws: number;
  black: number;
};

type LichessResponse = {
  white: number;
  draws: number;
  black: number;
  moves: LichessMove[];
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.join(__dirname, "..");
const datDir = path.join(projectRoot, "dat");
const outPath = path.join(projectRoot, "src", "lib", "openings.ts");

function parseTsv(content: string) {
  const lines = content.split(/\r?\n/).filter(Boolean);
  if (lines.length === 0) return [] as OpeningRow[];
  const headers = lines[0].split("\t");
  const ecoIdx = headers.indexOf("eco");
  const nameIdx = headers.indexOf("name");
  const pgnIdx = headers.indexOf("pgn");

  const rows: OpeningRow[] = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split("\t");
    const eco = cols[ecoIdx] || "";
    const name = cols[nameIdx] || "";
    const pgn = cols[pgnIdx] || "";
    if (eco && name && pgn) {
      rows.push({ eco, name, pgn });
    }
  }
  return rows;
}

function buildFenFromMoves(moves: ParsedMove[]): string {
  const board = new Board();
  for (const move of moves) {
    board.applySAN(move);
  }
  return board.toFen();
}

function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function progress(current: number, total: number) {
  const width = 24;
  const ratio = total === 0 ? 1 : current / total;
  const filled = Math.round(ratio * width);
  const bar = `${"#".repeat(filled)}${"-".repeat(Math.max(0, width - filled))}`;
  process.stdout.write(`\r[${bar}] ${current}/${total}`);
  if (current === total) process.stdout.write("\n");
}

async function fetchLichess(fen: string): Promise<LichessResponse> {
  if (typeof fetch !== "function") {
    throw new Error("fetch is not available in this Node runtime");
  }
  const url = `https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}`;
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Lichess request failed: ${res.status} ${res.statusText}`);
  }
  return (await res.json()) as LichessResponse;
}

async function run() {
  const tsvFiles = fs
    .readdirSync(datDir)
    .filter((file) => file.endsWith(".tsv"))
    .map((file) => path.join(datDir, file));

  const rows: OpeningRow[] = [];
  for (const file of tsvFiles) {
    const content = fs.readFileSync(file, "utf8");
    rows.push(...parseTsv(content));
  }

  const grouped = new Map<
    string,
    Array<{
      row: OpeningRow;
      parsed: ParsedMove[];
      lastSan: string | null;
    }>
  >();

  for (const row of rows) {
    const { parsed, sans } = parsePGN(row.pgn);
    if (sans.length === 0) {
      const fen = buildFenFromMoves([]);
      const group = grouped.get(fen) || [];
      group.push({ row, parsed, lastSan: null });
      grouped.set(fen, group);
      continue;
    }
    const prefixParsed = parsed.slice(0, -1);
    const fen = buildFenFromMoves(prefixParsed);
    const lastSan = sans[sans.length - 1];
    const group = grouped.get(fen) || [];
    group.push({ row, parsed, lastSan });
    grouped.set(fen, group);
  }

  const entries = Array.from(grouped.entries());
  const output: OpeningOutput[] = [];
  let index = 0;
  for (const [fen, items] of entries) {
    index += 1;
    progress(index, entries.length);
    const response = await fetchLichess(fen);

    for (const item of items) {
      let white = 0;
      let draws = 0;
      let black = 0;

      if (item.lastSan == null) {
        white = response.white;
        draws = response.draws;
        black = response.black;
      } else {
        const match = response.moves.find((move) => move.san === item.lastSan);
        if (!match) {
          throw new Error(`SAN not found for ${item.row.eco} ${item.row.name}: ${item.lastSan}`);
        }
        white = match.white;
        draws = match.draws;
        black = match.black;
      }

      output.push({
        eco: item.row.eco,
        name: item.row.name,
        pgn: item.row.pgn,
        moves: item.parsed,
        white,
        draws,
        black,
      });
    }

    if (index < entries.length) {
      await sleep(1000);
    }
  }

  const file =
    `// Generated by bin/gen.ts. Do not edit by hand.\n` +
    `import type { ParsedMove } from "./types";\n\n` +
    `export type Opening = {\n` +
    `  eco: string;\n` +
    `  name: string;\n` +
    `  pgn: string;\n` +
    `  moves: ParsedMove[];\n` +
    `  white: number;\n` +
    `  draws: number;\n` +
    `  black: number;\n` +
    `};\n\n` +
    `export const openings: Opening[] = ${JSON.stringify(output, null, 2)};\n`;

  fs.writeFileSync(outPath, file, "utf8");
  console.log(`Generated ${output.length} openings -> ${outPath}`);
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
